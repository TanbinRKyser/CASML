import pybloom_live as bf
import pandas as pd
import os
import multiprocessing

class BookLookup:
    def __init__(self, book_df):
        self.lookup_C = self.build_campus_lookup(book_df, "C")
        self.lookup_SD = self.build_campus_lookup(book_df, "SD")
        self.lookup_SFB = self.build_campus_lookup(book_df, "SFB")
        
        self.lookup_central = self.build_central_lookup(self.lookup_C, self.lookup_SD, self.lookup_SFB)

    def build_campus_lookup(self, dataframe, campus):
        """Creates an id lookup structure for a specified campus."""
        ### TODO: Add/Change code below
        campus_lookup = bf.BloomFilter(capacity=50_000_000, error_rate=0.0001)  # Create a Bloom filter
        
        filtered_rows = dataframe[dataframe['campus'] == campus]  # Filter rows for the specific campus
        
        for book_id in filtered_rows['book_id']:  # Iterate only through the filtered rows
            campus_lookup.add(book_id)  # Add the book ID to the Bloom filter
        ### TODO: Add/Change code above
        
        return campus_lookup

    def build_central_lookup(self, lookup_C, lookup_SD, lookup_SFB):
        """Creates a central id lookup structure."""
        ### TODO: Add/Change code below
        central_lookup = {
            "C": lookup_C,
            "SD": lookup_SD,
            "SFB": lookup_SFB
        }  # Combine all branch lookups into a single dictionary
        ### TODO: Add/Change code above
        
        return central_lookup

    def search_book(self, id_to_search):
        """Search for a book ID and return the respective campus."""
        ### TODO: Add/Change code below
        # if id_to_search in self.lookup_central["C"]:
        #     campus = "C"
        # elif id_to_search in self.lookup_central["SD"]:
        #     campus = "SD"
        # elif id_to_search in self.lookup_central["SFB"]:
        #     campus = "SFB"
        # else:
        #     campus = None
        campus = None
        for key, bloom_filter in self.lookup_central.items():
            if id_to_search in bloom_filter:  # Bloom filter match
                # Verify the ID explicitly in the dataset (optional but reduces false positives)
                campus = key
                break
        ### TODO: Add/Change code above
        
        return campus if campus else "Book Not Found in Lookup!"

def lookup_books(books, ids_to_search):
    """Creates a BookLookup instance and looks up a list of book IDs."""
    ### TODO: Add/Change code below
    book_lookup = BookLookup(books)
    lookups = [book_lookup.search_book(book_id) for book_id in ids_to_search]  # Query each book ID
    ### TODO: Add/Change code above
    
    return lookups

# def process_chunk(chunk, ids_to_search):
#     chunk["campus"] = chunk["campus"].str.strip().str.upper()  # Normalize campus column
#     book_lookup = BookLookup(chunk)
#     return [book_lookup.search_book(book_id) for book_id in ids_to_search]

if __name__ == "__main__":
    ### NOTE: The main clause will not be graded, change for your own convenience  
    ### TODO: Add/Change code below

    #print(os.path.exists("books.csv"))
    book_file = os.path.abspath("books.csv")  # Generated by identifier_generator.py
    
    chunksize = 10_000_00  # Process in 1 million row chunks

    
    book_chunks = pd.read_csv(book_file, chunksize=chunksize, header=None, names=["book_id", "campus"])

   
   # ids_to_search = ["B00000001", "B12345678", "B00000003","B99999999","B00000004"]  
    ids_to_search = ["B12345678"]
    # for chunk in book_chunks:
    #     result = lookup_books(chunk, ids_to_search)
    #     print(result)   

    # Use multiprocessing to process chunks in parallel
    # with multiprocessing.Pool(processes=4) as pool:
    #     results = pool.starmap(process_chunk, [(chunk, ids_to_search) for chunk in book_chunks])

    # # Combine and print results
    # final_results = {}
    # for res in results:
    #     for book_id, campus in zip(ids_to_search, res):
    #         if book_id not in final_results or final_results[book_id] == "Book Not Found in Lookup!":
    #             final_results[book_id] = "Book Not Found in Lookup!"

    final_results = {}

    for chunk in book_chunks:
        # Normalize campus column (if necessary)
        chunk["campus"] = chunk["campus"].str.strip().str.upper()

        # Create the lookup structure for the current chunk
        results = lookup_books(chunk, ids_to_search)

        # Accumulate results
        for book_id, campus in zip(ids_to_search, results):
            if book_id not in final_results or final_results[book_id] == "Book Not Found in Lookup!":
                final_results[book_id] = "Book Not Found!"

    # Print consolidated results
    for book_id, result in final_results.items():
        print(f"Book ID: {book_id}, Campus: {result}")